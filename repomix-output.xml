This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  components/
    AppHeader.vue
    Pagination.vue
    PokemonGrid.vue
  middleware/
    auth.ts
  pages/
    index.vue
    login.vue
    profile.vue
  plugins/
    auth.client.ts
    init-store.server.ts
  services/
    authService.ts
    pokemonService.ts
  stores/
    auth.ts
    pokemon.ts
  types/
    auth.ts
    supabase.ts
    validation.ts
  app.vue
public/
  robots.txt
server/
  api/
    initial-pokemon.get.ts
    pokemon-count.get.ts
  plugins/
    supabase.ts
  utils/
    usePokemon.ts
nuxt.config.ts
package.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/components/AppHeader.vue">
<!-- app/components/AppHeader.vue -->
<script setup lang="ts">
import { useAuthStore } from '@/stores/auth'

const authStore = useAuthStore()

const handleLogout = async () => {
  const result = await authStore.signOut()
  if (result.success) {
    console.log('ログアウトしました')
  }
}
</script>

<template>
  <header class="mb-6">
    <div class="flex justify-between items-center">
      <h1 class="text-3xl font-bold text-center">ポケモン図鑑</h1>
      
      <!-- 認証エリア -->
      <div class="flex items-center gap-4">
        <!-- ClientOnlyで囲んでSSRをスキップ -->
        <ClientOnly>
          <div v-if="authStore.isAuthenticated" class="flex items-center gap-3">
            <span class="text-sm text-gray-600">
              こんにちは、{{ authStore.userEmail }}さん
            </span>
            <button 
              @click="handleLogout"
              :disabled="authStore.isLoading"
              class="px-3 py-1 text-sm bg-red-500 text-white rounded hover:bg-red-600 disabled:opacity-50"
            >
              ログアウト
            </button>
          </div>
          
          <div v-else class="flex items-center gap-3">
            <NuxtLink 
              to="/login" 
              class="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              ログイン
            </NuxtLink>
          </div>
          
          <!-- 読み込み中の表示 -->
          <template #fallback>
            <div class="flex items-center gap-3">
              <div class="px-3 py-1 text-sm bg-gray-300 text-gray-600 rounded">
                読み込み中...
              </div>
            </div>
          </template>
        </ClientOnly>
      </div>
    </div>
  </header>
</template>
</file>

<file path="app/components/Pagination.vue">
<script setup lang="ts">
interface Props {
  currentPage: number
  totalPages: number
  loading?: boolean
}

interface Emits {
  (event: 'page-change', page: number): void
}

const props = withDefaults(defineProps<Props>(), {
  loading: false
})

const emit = defineEmits<Emits>()

// ページ変更処理
const changePage = (page: number) => {
  if (page < 1 || page > props.totalPages || props.loading || page === props.currentPage) {
    return
  }
  emit('page-change', page)
}

// 表示するページ番号の配列を計算
const visiblePages = computed(() => {
  const current = props.currentPage
  const total = props.totalPages
  const pages = []
  
  if (total <= 7) {
    // 総ページ数が7以下なら全て表示
    for (let i = 1; i <= total; i++) {
      pages.push(i)
    }
  } else {
    // 現在のページを中心に最大5ページを表示
    let start = Math.max(1, current - 2)
    let end = Math.min(total, current + 2)
    
    // 端に寄りすぎた場合の調整
    if (end - start < 4) {
      if (start === 1) {
        end = Math.min(total, start + 4)
      } else {
        start = Math.max(1, end - 4)
      }
    }
    
    for (let i = start; i <= end; i++) {
      pages.push(i)
    }
  }
  
  return pages
})

// 最初のページを表示するか
const showFirstPage = computed(() => {
  return props.totalPages > 7 && (visiblePages.value[0] ?? 0) > 1
})

// 最後のページを表示するか
const showLastPage = computed(() => {
  const lastVisiblePage = visiblePages.value[visiblePages.value.length - 1] ?? 0
  return props.totalPages > 7 && lastVisiblePage < props.totalPages
})

// 省略記号を表示するか（前）
const showStartEllipsis = computed(() => {
  return showFirstPage.value && (visiblePages.value[0] ?? 0) > 2
})

// 省略記号を表示するか（後）
const showEndEllipsis = computed(() => {
  const lastVisiblePage = visiblePages.value[visiblePages.value.length - 1] ?? 0
  return showLastPage.value && lastVisiblePage < props.totalPages - 1
})
</script>

<template>
  <div class="flex justify-center items-center gap-2 flex-wrap">
    <!-- 前のページボタン -->
    <button
      :disabled="currentPage === 1 || loading"
      @click="changePage(currentPage - 1)"
      class="px-3 py-2 rounded-md bg-blue-500 text-white text-sm font-medium disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-blue-600 active:bg-blue-700 transition-colors duration-200focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1"
    >
      <span class="sr-only">前のページ</span>
      ← 前
    </button>

    <!-- 最初のページ -->
    <button
      v-if="showFirstPage"
      @click="changePage(1)"
      :disabled="loading"
      class="px-3 py-2 rounded-md border border-gray-300 bg-white text-gray-700 text-sm font-mediumhover:bg-gray-50 active:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowedtransition-colors duration-200focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1"
    >
      1
    </button>
    
    <!-- 省略記号（前） -->
    <span 
      v-if="showStartEllipsis" 
      class="px-2 py-2 text-gray-500 text-sm"
      aria-hidden="true"
    >
      ...
    </span>

    <!-- 表示するページ番号 -->
    <button
      v-for="page in visiblePages"
      :key="page"
      @click="changePage(page)"
      :disabled="loading"
      :class="{
        'bg-blue-500 text-white border-blue-500': page === currentPage,
        'bg-white text-gray-700 border-gray-300 hover:bg-gray-50': page !== currentPage
      }"
      class="px-3 py-2 rounded-md border text-sm font-mediumactive:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowedtransition-colors duration-200focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1"
    >
      {{ page }}
    </button>

    <!-- 省略記号（後） -->
    <span 
      v-if="showEndEllipsis" 
      class="px-2 py-2 text-gray-500 text-sm"
      aria-hidden="true"
    >
      ...
    </span>

    <!-- 最後のページ -->
    <button
      v-if="showLastPage"
      @click="changePage(totalPages)"
      :disabled="loading"
      class="px-3 py-2 rounded-md border border-gray-300 bg-white text-gray-700 text-sm font-mediumhover:bg-gray-50 active:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowedtransition-colors duration-200focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1"
    >
      {{ totalPages }}
    </button>

    <!-- 次のページボタン -->
    <button
      :disabled="currentPage === totalPages || loading"
      @click="changePage(currentPage + 1)"
      class="px-3 py-2 rounded-md bg-blue-500 text-white text-sm font-medium disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-blue-600 active:bg-blue-700 transition-colors duration-200focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1"
    >
      <span class="sr-only">次のページ</span>
      次 →
    </button>
  </div>

  <!-- ページ情報表示 -->
  <div class="text-center mt-4 text-sm text-gray-600">
    {{ currentPage }} / {{ totalPages }} ページ
    <span v-if="loading" class="ml-2 text-blue-600">
      読み込み中...
    </span>
  </div>
</template>
</file>

<file path="app/components/PokemonGrid.vue">
<!-- app/components/PokemonGrid.vue -->
<script setup lang="ts">
import type { Database } from '@/types/supabase'

type Pokemon = Pick<Database['public']['Tables']['pokemon']['Row'], 'id' | 'name' | 'japanese_name' | 'sprite_url'>

interface Props {
  pokemon: Pokemon[]
  loading?: boolean
  columns?: {
    sm: number
    md: number
    lg: number
  }
}

interface Emits {
  (event: 'pokemon-click', pokemonId: number): void
}

const props = withDefaults(defineProps<Props>(), {
  loading: false,
  columns: () => ({
    sm: 2,
    md: 4,
    lg: 6
  })
})

const emit = defineEmits<Emits>()

// ポケモンクリック処理
const handlePokemonClick = (pokemonId: number) => {
  if (props.loading) return
  emit('pokemon-click', pokemonId)
}

// グリッドのCSSクラスを動的に生成
const gridClasses = computed(() => {
  const { sm, md, lg } = props.columns
  
  // Tailwindの既存クラスをマッピング
  const getGridCols = (cols: number) => {
    const gridMap: Record<number, string> = {
      1: 'grid-cols-1',
      2: 'grid-cols-2',
      3: 'grid-cols-3',
      4: 'grid-cols-4',
      5: 'grid-cols-5',
      6: 'grid-cols-6',
      7: 'grid-cols-7',
      8: 'grid-cols-8'
    }
    return gridMap[cols] || 'grid-cols-4'
  }
  
  const getMdGridCols = (cols: number) => {
    const gridMap: Record<number, string> = {
      1: 'md:grid-cols-1',
      2: 'md:grid-cols-2',
      3: 'md:grid-cols-3',
      4: 'md:grid-cols-4',
      5: 'md:grid-cols-5',
      6: 'md:grid-cols-6',
      7: 'md:grid-cols-7',
      8: 'md:grid-cols-8'
    }
    return gridMap[cols] || 'md:grid-cols-4'
  }
  
  const getLgGridCols = (cols: number) => {
    const gridMap: Record<number, string> = {
      1: 'lg:grid-cols-1',
      2: 'lg:grid-cols-2',
      3: 'lg:grid-cols-3',
      4: 'lg:grid-cols-4',
      5: 'lg:grid-cols-5',
      6: 'lg:grid-cols-6',
      7: 'lg:grid-cols-7',
      8: 'lg:grid-cols-8'
    }
    return gridMap[cols] || 'lg:grid-cols-6'
  }
  
  return [
    'grid gap-4',
    getGridCols(sm),
    getMdGridCols(md),
    getLgGridCols(lg)
  ].join(' ')
})
</script>

<template>
  <div 
    :class="[gridClasses, { 'opacity-60 pointer-events-none': loading }]"
    class="mb-8"
  >
    <!-- 空の状態 -->
    <div 
      v-if="pokemon.length === 0 && !loading"
      class="col-span-full text-center py-12"
    >
      <div class="text-gray-400 mb-4">
        <svg class="w-16 h-16 mx-auto" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
        </svg>
      </div>
      <p class="text-lg text-gray-600">ポケモンが見つかりませんでした</p>
      <p class="text-sm text-gray-500">検索条件を変更してみてください</p>
    </div>

    <!-- ポケモンカード -->
    <div 
      v-for="pokemon in pokemon" 
      :key="pokemon.id"
      class="bg-white rounded-lg shadow-md p-4 hover:shadow-lg hover:scale-105 transition-all duration-200 cursor-pointer border border-gray-200 relative"
      @click="handlePokemonClick(pokemon.id)"
    >
      <!-- ローディング中のオーバーレイ -->
      <div 
        v-if="loading"
        class="absolute inset-0 bg-white bg-opacity-70 flex items-center justify-center rounded-lg z-10"
      >
        <div class="w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
      </div>

      <!-- ポケモン画像 -->
      <div class="relative mb-3">
        <img 
          :src="pokemon.sprite_url || '/placeholder-pokemon.png'" 
          :alt="pokemon.japanese_name || pokemon.name"
          class="w-full h-24 object-contain"
          loading="lazy"
          @error="($event.target as HTMLImageElement).src = '/placeholder-pokemon.png'"
        >
      </div>

      <!-- ポケモン情報 -->
      <div class="text-center">
        <p class="text-sm font-semibold text-gray-800 mb-1">
          No.{{ pokemon.id.toString().padStart(3, '0') }}
        </p>
        <p class="text-xs text-gray-600 line-clamp-2 min-h-[2rem]">
          {{ pokemon.japanese_name || pokemon.name }}
        </p>
      </div>
    </div>
  </div>

  <!-- ローディング中の追加表示 -->
  <div v-if="loading" class="text-center mt-4">
    <div class="inline-flex items-center gap-2 text-blue-600">
      <div class="w-4 h-4 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
      <span class="text-sm">読み込み中...</span>
    </div>
  </div>
</template>

<style scoped>
/* テキストを2行に制限 */
.line-clamp-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

/* ホバー効果の改善 */
.group:hover .group-hover\:scale-110 {
  transform: scale(1.1);
}

/* カードの高さを統一 */
.bg-white {
  min-height: 140px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}
</style>
</file>

<file path="app/pages/login.vue">
<!-- app/pages/login.vue -->
<script setup lang="ts">
import { useAuthStore } from '@/stores/auth'

const authStore = useAuthStore()

// フォームデータ
const email = ref('')
const password = ref('')
const isSignUp = ref(false) // ログイン/サインアップの切り替え
const errorMessage = ref('')
const successMessage = ref('')

// ログイン処理
const handleSignIn = async () => {
  errorMessage.value = ''
  
  const result = await authStore.signIn(email.value, password.value)
  
  if (result.success) {
    // リダイレクト先があればそこに、なければホームに遷移
    const route = useRoute()
    const redirectTo = route.query.redirect as string || '/'
    await navigateTo(redirectTo)
  } else {
    errorMessage.value = result.error || 'ログインに失敗しました'
  }
}

// サインアップ処理
const handleSignUp = async () => {
  errorMessage.value = ''
  successMessage.value = ''
  
  const result = await authStore.signUp(email.value, password.value)
  
  if (result.success) {
    if (result.needsConfirmation) {
      successMessage.value = '確認メールを送信しました。メールをご確認ください。'
    } else {
      // リダイレクト先があればそこに、なければホームに遷移
      const route = useRoute()
      const redirectTo = route.query.redirect as string || '/'
      await navigateTo(redirectTo)
    }
  } else {
    errorMessage.value = result.error || 'アカウント作成に失敗しました'
  }
}

// フォーム送信
const handleSubmit = () => {
  if (isSignUp.value) {
    handleSignUp()
  } else {
    handleSignIn()
  }
}

// 既にログインしている場合はリダイレクト
onMounted(async () => {
  // 認証状態の初期化を待つ
  if (import.meta.client) {
    // 認証状態が初期化されるまで待つ
    while (!authStore.isInitialized) {
      await new Promise(resolve => setTimeout(resolve, 50))
    }
    
    if (authStore.isAuthenticated) {
      // リダイレクト先があればそこに、なければホームに遷移
      const route = useRoute()
      const redirectTo = route.query.redirect as string || '/'
      await navigateTo(redirectTo)
    }
  }
})
</script>

<template>
  <div class="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
    <div class="max-w-md w-full space-y-8">
      <ClientOnly>
        <!-- ヘッダー -->
        <div>
          <h2 class="mt-6 text-center text-3xl font-extrabold text-gray-900">
            {{ isSignUp ? 'アカウント作成' : 'ログイン' }}
          </h2>
          <p class="mt-2 text-center text-sm text-gray-600">
            ポケモン図鑑アプリへようこそ
          </p>
        </div>

        <!-- フォーム -->
        <form class="mt-8 space-y-6" @submit.prevent="handleSubmit">
          <!-- メールアドレス -->
          <div>
            <label for="email" class="block text-sm font-medium text-gray-700">
              メールアドレス
            </label>
            <input
              id="email"
              v-model="email"
              type="email"
              required
              class="mt-1 appearance-none rounded-md relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
              placeholder="email@example.com"
            />
          </div>

          <!-- パスワード -->
          <div>
            <label for="password" class="block text-sm font-medium text-gray-700">
              パスワード
            </label>
            <input
              id="password"
              v-model="password"
              type="password"
              required
              class="mt-1 appearance-none rounded-md relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
              placeholder="パスワード（6文字以上）"
            />
          </div>

          <!-- エラーメッセージ -->
          <div v-if="errorMessage" class="bg-red-50 border border-red-200 rounded-md p-3">
            <p class="text-sm text-red-600">{{ errorMessage }}</p>
          </div>

          <!-- 成功メッセージ -->
          <div v-if="successMessage" class="bg-green-50 border border-green-200 rounded-md p-3">
            <p class="text-sm text-green-600">{{ successMessage }}</p>
          </div>

          <!-- 送信ボタン -->
          <div>
            <button
              type="submit"
              :disabled="authStore.isLoading"
              class="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <span v-if="authStore.isLoading" class="mr-2">
                <div class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
              </span>
              {{ authStore.isLoading ? '処理中...' : (isSignUp ? 'アカウント作成' : 'ログイン') }}
            </button>
          </div>

          <!-- モード切り替え -->
          <div class="text-center">
            <button
              type="button"
              @click="isSignUp = !isSignUp"
              class="text-sm text-blue-600 hover:text-blue-500"
            >
              {{ isSignUp ? 'すでにアカウントをお持ちですか？ログインする' : 'アカウントを作成する' }}
            </button>
          </div>
        </form>

        <!-- ホームに戻るリンク -->
        <div class="text-center">
          <NuxtLink 
            to="/" 
            class="text-sm text-gray-500 hover:text-gray-700"
          >
            ← ホームに戻る
          </NuxtLink>
        </div>
        
        <!-- 読み込み中の表示 -->
        <template #fallback>
          <div class="text-center py-8">
            <div class="inline-flex items-center justify-center w-16 h-16 mb-4">
              <div class="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
            </div>
            <p class="text-lg text-gray-600">読み込み中...</p>
          </div>
        </template>
      </ClientOnly>
    </div>
  </div>
</template>
</file>

<file path="app/pages/profile.vue">
<!-- app/pages/profile.vue -->
<script setup lang="ts">
import { useAuthStore } from '@/stores/auth'

// 認証ミドルウェアを適用
definePageMeta({
  middleware: 'auth'
})

const authStore = useAuthStore()

// ログアウト処理
const handleLogout = async () => {
  const result = await authStore.signOut()
  if (result.success) {
    await navigateTo('/login')
  }
}
</script>

<template>
  <div class="container mx-auto p-4 max-w-2xl">
    <!-- ヘッダー -->
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-3xl font-bold">プロフィール</h1>
      <NuxtLink 
        to="/" 
        class="px-3 py-1 text-sm bg-gray-500 text-white rounded hover:bg-gray-600"
      >
        ← ホームに戻る
      </NuxtLink>
    </div>

    <!-- ユーザー情報 -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
      <h2 class="text-xl font-semibold mb-4">ユーザー情報</h2>
      
      <ClientOnly>
        <div class="space-y-3">
          <div>
            <label class="block text-sm font-medium text-gray-700">メールアドレス</label>
            <p class="mt-1 text-sm text-gray-900">{{ authStore.userEmail }}</p>
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700">ログイン状態</label>
            <p class="mt-1 text-sm text-green-600">ログイン中</p>
          </div>
        </div>
        
        <!-- 読み込み中の表示 -->
        <template #fallback>
          <div class="space-y-3">
            <div>
              <label class="block text-sm font-medium text-gray-700">メールアドレス</label>
              <p class="mt-1 text-sm text-gray-500">読み込み中...</p>
            </div>
            
            <div>
              <label class="block text-sm font-medium text-gray-700">ログイン状態</label>
              <p class="mt-1 text-sm text-gray-500">確認中...</p>
            </div>
          </div>
        </template>
      </ClientOnly>
    </div>

    <!-- アクション -->
    <div class="bg-white rounded-lg shadow-md p-6">
      <h2 class="text-xl font-semibold mb-4">アクション</h2>
      
      <div class="space-y-3">
        <button 
          @click="handleLogout"
          :disabled="authStore.isLoading"
          class="w-full px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 disabled:opacity-50"
        >
          {{ authStore.isLoading ? 'ログアウト中...' : 'ログアウト' }}
        </button>
        
        <p class="text-xs text-gray-500">
          ログアウトすると、ログインページに戻ります。
        </p>
      </div>
    </div>
  </div>
</template>
</file>

<file path="app/plugins/init-store.server.ts">
// plugins/init-store.server.ts
import { usePokemonStore } from '@/stores/pokemon'

export default defineNuxtPlugin(async () => {
  const pokemonStore = usePokemonStore()
  
  // SSR時にStore初期化
  if (!pokemonStore.isInitialized) {
    try {
      await pokemonStore.initializeStore()
      console.log('SSR: Store初期化完了')
    } catch (error) {
      console.error('SSR: Store初期化に失敗:', error)
    }
  }
})
</file>

<file path="app/services/pokemonService.ts">
// app/services/pokemonService.ts
import type { Database } from '@/types/supabase'

type Pokemon = Database['public']['Tables']['pokemon']['Row']

// API レスポンスの型定義
export interface PokemonCountResponse {
  count: number
}

export interface InitialPokemonResponse {
  data: Pick<Pokemon, 'id' | 'name' | 'japanese_name' | 'sprite_url'>[]
  pagination: {
    page: number
    itemsPerPage: number
    offset: number
    returnedCount: number
  }
}

export interface PokemonDetailResponse extends Pokemon {}

export class PokemonService {
  /**
   * ポケモンの総数を取得
   */
  async getPokemonCount(): Promise<PokemonCountResponse> {
    try {
      const result = await $fetch<PokemonCountResponse>('/api/pokemon-count')
      return result
    } catch (error) {
      console.error('ポケモン総数取得エラー:', error)
      throw new Error('ポケモンの総数を取得できませんでした')
    }
  }

  /**
   * 初期ポケモンデータを取得（ページネーション対応）
   */
  async getInitialPokemon(page: number = 1, limit: number = 30): Promise<InitialPokemonResponse> {
    try {
      const result = await $fetch<InitialPokemonResponse>('/api/initial-pokemon', {
        query: { 
          page, 
          limit 
        }
      })
      return result
    } catch (error) {
      console.error(`ポケモンデータ取得エラー (page: ${page}):`, error)
      throw new Error(`${page}ページ目のポケモンデータを取得できませんでした`)
    }
  }

  /**
   * 指定したページのポケモンデータを取得
   */
  async getPokemonByPage(page: number, limit: number = 30): Promise<InitialPokemonResponse> {
    return this.getInitialPokemon(page, limit)
  }

  /**
   * 特定のポケモンの詳細情報を取得
   */
  async getPokemonById(id: number): Promise<PokemonDetailResponse> {
    try {
      const result = await $fetch<PokemonDetailResponse>(`/api/pokemon/${id}`)
      return result
    } catch (error) {
      console.error(`ポケモン詳細取得エラー (id: ${id}):`, error)
      throw new Error(`ポケモン(ID: ${id})の詳細情報を取得できませんでした`)
    }
  }

  /**
   * 並行してカウントと初期データを取得（Store初期化用）
   */
  async getInitialData(page: number = 1, limit: number = 30): Promise<{
    count: PokemonCountResponse
    pokemon: InitialPokemonResponse
  }> {
    try {
      const [countResult, pokemonResult] = await Promise.all([
        this.getPokemonCount(),
        this.getInitialPokemon(page, limit)
      ])

      return {
        count: countResult,
        pokemon: pokemonResult
      }
    } catch (error) {
      console.error('初期データ取得エラー:', error)
      throw new Error('初期データの取得に失敗しました')
    }
  }
}

// シングルトンインスタンスをエクスポート
export const pokemonService = new PokemonService()
</file>

<file path="app/types/auth.ts">
// app/types/auth.ts
import type { SupabaseUser, SupabaseSession, Profile } from './supabase'

// 認証状態の型
export interface AuthState {
  user: SupabaseUser | null
  session: SupabaseSession | null
  profile: Profile | null
  isLoading: boolean
  isInitialized: boolean
}

// ログインフォームの型
export interface LoginForm {
  email: string
  password: string
}

// サインアップフォームの型
export interface SignupForm {
  email: string
  password: string
  confirmPassword: string
  username?: string
}

// プロフィール更新フォームの型
export interface ProfileUpdateForm {
  username: string
  avatar_url?: string
}

// パスワードリセットフォームの型
export interface PasswordResetForm {
  email: string
}

// パスワード変更フォームの型
export interface PasswordUpdateForm {
  currentPassword: string
  newPassword: string
  confirmNewPassword: string
}

// 認証エラーの型
export interface AuthError {
  message: string
  status?: number
  code?: string
}

// 認証レスポンスの型
export interface AuthResponse<T = any> {
  data: T | null
  error: AuthError | null
  success: boolean
}

// フォームバリデーション結果の型
export interface ValidationResult {
  isValid: boolean
  errors: Record<string, string>
}

// 認証プロバイダーの型
export type AuthProvider = 'google' | 'github' | 'discord' | 'twitter'

// 認証イベントの型
export type AuthEvent = 
  | 'SIGNED_IN' 
  | 'SIGNED_OUT' 
  | 'TOKEN_REFRESHED' 
  | 'USER_UPDATED' 
  | 'PASSWORD_RECOVERY'

// ユーザーロールの型（将来的な拡張用）
export type UserRole = 'user' | 'admin' | 'moderator'

// 拡張ユーザー情報の型
export interface ExtendedUser {
  id: string
  email: string
  username?: string
  avatar_url?: string
  role: UserRole
  emailConfirmed: boolean
  createdAt: string
  lastSignIn?: string
}
</file>

<file path="app/types/validation.ts">
// app/types/validation.ts

// バリデーションルールの型
export interface ValidationRule {
  required?: boolean
  minLength?: number
  maxLength?: number
  pattern?: RegExp
  custom?: (value: any) => boolean | string
}

// フィールドバリデーション設定の型
export interface FieldValidation {
  [fieldName: string]: ValidationRule
}

// バリデーション結果の型
export interface FieldValidationResult {
  isValid: boolean
  error: string | null
}

// フォーム全体のバリデーション結果の型
export interface FormValidationResult {
  isValid: boolean
  errors: Record<string, string>
  fields: Record<string, FieldValidationResult>
}

// 共通バリデーションルール
export const VALIDATION_RULES = {
  email: {
    required: true,
    pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
    maxLength: 255
  },
  password: {
    required: true,
    minLength: 6,
    maxLength: 128
  },
  username: {
    required: false,
    minLength: 3,
    maxLength: 30,
    pattern: /^[a-zA-Z0-9_-]+$/
  },
  confirmPassword: {
    required: true,
    minLength: 6,
    maxLength: 128
  }
} as const

// バリデーションメッセージ
export const VALIDATION_MESSAGES = {
  required: (field: string) => `${field}は必須です`,
  minLength: (field: string, min: number) => `${field}は${min}文字以上で入力してください`,
  maxLength: (field: string, max: number) => `${field}は${max}文字以下で入力してください`,
  pattern: (field: string) => `${field}の形式が正しくありません`,
  passwordMismatch: 'パスワードが一致しません',
  emailInvalid: 'メールアドレスの形式が正しくありません',
  usernameInvalid: 'ユーザー名は英数字、アンダースコア、ハイフンのみ使用できます'
} as const
</file>

<file path="public/robots.txt">
User-Agent: *
Disallow:
</file>

<file path="server/plugins/supabase.ts">
// server/plugins/supabase.ts
import { createClient } from '@supabase/supabase-js'
import type { Database } from '@/types/supabase'

export default defineNitroPlugin((nitroApp) => {
  const config = useRuntimeConfig()
  
  const supabase = createClient<Database>(
    config.public.supabaseUrl,
    config.public.supabaseAnonKey
  )

  // 【重要】Nitroのコンテキストにsupabaseを追加
  nitroApp.hooks.hook('request', (event) => {
    event.context.supabase = supabase
  })
})

// 型定義を拡張
declare module 'h3' {
  interface H3EventContext {
    supabase: ReturnType<typeof createClient<Database>>
  }
}
</file>

<file path="tsconfig.json">
{
  // https://nuxt.com/docs/guide/concepts/typescript
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="app/middleware/auth.ts">
// middleware/auth.ts
import { useAuthStore } from '@/stores/auth'

export default defineNuxtRouteMiddleware(async (to, from) => {
  // サーバーサイドでは認証が必要なページかどうかのみチェック
  if (import.meta.server) {
    // 公開ページは通す（ログインページなど）
    const publicRoutes = ['/login', '/']
    if (publicRoutes.includes(to.path)) {
      return
    }
    return navigateTo(`/login?redirect=${encodeURIComponent(to.path)}`)
  }

  // クライアントサイドでの詳細な認証チェック
  if (import.meta.client) {
    const authStore = useAuthStore()
    
    // より効率的な初期化待機
    if (!authStore.isInitialized) {
      await authStore.waitForInitialization()
    }

    if (!authStore.isAuthenticated) {
      return navigateTo(`/login?redirect=${encodeURIComponent(to.path)}`)
    }
  }
})
</file>

<file path="app/services/authService.ts">
// app/services/authService.ts
import { createClient } from '@supabase/supabase-js'
import type { Database } from '@/types/supabase'

export class AuthService {
  private supabase: ReturnType<typeof createClient<Database>> | null = null

  private getSupabase() {
    if (!this.supabase) {
      const config = useRuntimeConfig()
      this.supabase = createClient<Database>(
        config.public.supabaseUrl,
        config.public.supabaseAnonKey
      )
    }
    return this.supabase
  }

  // ログイン
  async signIn(email: string, password: string) {
    const { data, error } = await this.getSupabase().auth.signInWithPassword({
      email,
      password
    })

    if (error) throw new Error(error.message)
    console.log('Sign-up data:', data) // デバッグ用ログ
    return data
  }

  // サインアップ
  async signUp(email: string, password: string) {
    const { data, error } = await this.getSupabase().auth.signUp({
      email,
      password
    })

    if (error) throw new Error(error.message)
    return data
  }

  // ログアウト
  async signOut() {
    const { error } = await this.getSupabase().auth.signOut()
    if (error) throw new Error(error.message)
  }

  // 現在のユーザーを取得
  async getCurrentUser() {
    const { data: { user } } = await this.getSupabase().auth.getUser()
    return user
  }

  // 現在のセッションを取得
  async getCurrentSession() {
    const { data: { session } } = await this.getSupabase().auth.getSession()
    return session
  }

  // 認証状態の変更を監視
  onAuthStateChange(callback: (event: string, session: any) => void) {
    return this.getSupabase().auth.onAuthStateChange(callback)
  }
}

// 1つのインスタンスを作成してエクスポート
export const authService = new AuthService()
</file>

<file path="app/stores/pokemon.ts">
// stores/pokemon.ts
import { defineStore } from 'pinia'
import { pokemonService } from '@/services/pokemonService'
import type { Database } from '@/types/supabase'

type Pokemon = Database['public']['Tables']['pokemon']['Row']

interface PokemonState {
  totalCount: number
  initialPokemon: Pick<Pokemon, 'id' | 'name' | 'japanese_name' | 'sprite_url'>[]
  types: string[]
  pagination: {
    itemsPerPage: number
    currentPage: number
    totalPages: number
  }
  isInitialized: boolean
}

export const usePokemonStore = defineStore('pokemon', {
  state: (): PokemonState => ({
    totalCount: 0,
    initialPokemon: [],
    types: [
      'ノーマル', 'ほのお', 'みず', 'でんき', 'くさ', 'こおり', 
      'かくとう', 'どく', 'じめん', 'ひこう', 'エスパー', 'むし', 
      'いわ', 'ゴースト', 'ドラゴン', 'あく', 'はがね', 'フェアリー'
    ],
    pagination: {
      itemsPerPage: 30,
      currentPage: 1,
      totalPages: 0
    },
    isInitialized: false
  }),

  getters: {
    getPokemonById: (state) => (id: number) => {
      return state.initialPokemon.find(pokemon => pokemon.id === id)
    },
    getTotalPages: (state) => {
      return Math.ceil(state.totalCount / state.pagination.itemsPerPage)
    }
  },

  actions: {
    async initializeStore() {
      if (this.isInitialized) return
      
      try {
        // 総数と初期データ（1ページ目）を並行取得
        const { count, pokemon } = await pokemonService.getInitialData(
          this.pagination.currentPage, 
          this.pagination.itemsPerPage
        )
        
        this.totalCount = count.count
        this.initialPokemon = pokemon.data
        this.pagination.totalPages = Math.ceil(this.totalCount / this.pagination.itemsPerPage)
        this.isInitialized = true
        
        console.log(
          `初期化完了: 総数${this.totalCount}、` +
          `${this.pagination.currentPage}ページ目 ${pokemon.data.length}件、` +
          `全${this.pagination.totalPages}ページ`
        )
      } catch (error) {
        console.error('Store初期化エラー:', error)
        throw error
      }
    },

    async loadPage(page: number) {
      try {
        const result = await pokemonService.getPokemonByPage(page, this.pagination.itemsPerPage)

        this.initialPokemon = result.data
        this.pagination.currentPage = page
        
        console.log(`${page}ページ目読み込み完了: ${result.data.length}件`)
        return result.data
      } catch (error) {
        console.error(`${page}ページ目の読み込みエラー:`, error)
        throw error
      }
    }
  }
})
</file>

<file path="app/types/supabase.ts">
// app/types/supabase.ts
import type { User, Session } from '@supabase/supabase-js'

export interface Database {
  public: {
    Tables: {
      pokemon: {
        Row: {
          id: number
          name: string
          japanese_name: string | null
          height: number
          weight: number
          sprite_url: string | null
          types: string[]
          stats: {
            hp: number
            attack: number
            defense: number
          }
          created_at: string
        }
        Insert: {
          id: number
          name: string
          japanese_name?: string | null
          height: number
          weight: number
          sprite_url?: string | null
          types: string[]
          stats: {
            hp: number
            attack: number
            defense: number
          }
        }
        Update: {
          id?: number
          name?: string
          japanese_name?: string | null
          height?: number
          weight?: number
          sprite_url?: string | null
          types?: string[]
          stats?: {
            hp: number
            attack: number
            defense: number
          }
        }
      }
      profiles: {
        Row: {
          id: string
          username: string | null
          avatar_url: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id: string
          username?: string | null
          avatar_url?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          username?: string | null
          avatar_url?: string | null
          updated_at?: string
        }
      }
      user_favorites: {
        Row: {
          id: string
          user_id: string
          pokemon_id: number
          created_at: string
        }
        Insert: {
          id?: string
          user_id: string
          pokemon_id: number
          created_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          pokemon_id?: number
        }
      }
    }
  }
}

// 認証関連の型定義
export type SupabaseUser = User
export type SupabaseSession = Session

// プロフィール型
export type Profile = Database['public']['Tables']['profiles']['Row']
export type ProfileInsert = Database['public']['Tables']['profiles']['Insert']
export type ProfileUpdate = Database['public']['Tables']['profiles']['Update']

// お気に入り型
export type UserFavorite = Database['public']['Tables']['user_favorites']['Row']
export type UserFavoriteInsert = Database['public']['Tables']['user_favorites']['Insert']

// ポケモン型（既存）
export type Pokemon = Database['public']['Tables']['pokemon']['Row']
export type PokemonInsert = Database['public']['Tables']['pokemon']['Insert']
export type PokemonUpdate = Database['public']['Tables']['pokemon']['Update']
</file>

<file path="app/app.vue">
<template>
  <div>
    <NuxtPage />
  </div>
</template>
</file>

<file path="server/api/initial-pokemon.get.ts">
// server/api/initial-pokemon.get.ts
import { serverUsePokemon } from '../../server/utils/usePokemon'

export default defineEventHandler(async (event) => {
  const { getInitPokemon } = serverUsePokemon(event)

  try {
    // クエリパラメータから取得、デフォルトは1ページ目
    const query = getQuery(event)
    const page = Number(query.page) || 1
    const itemsPerPage = Number(query.limit) || 30
    
    // ページネーション計算
    const offset = (page - 1) * itemsPerPage
    const limit = offset + itemsPerPage - 1
    
    const data = await getInitPokemon(offset, limit)
    
    return {
      data: data || [],
      pagination: {
        page,
        itemsPerPage,
        offset,
        returnedCount: data?.length || 0
      }
    }
  } catch (error) {
    console.error('Initial pokemon API error:', error)
    throw error
  }
})
</file>

<file path="server/api/pokemon-count.get.ts">
// server/api/pokemon-count.get.ts
import { serverUsePokemon } from '../../server/utils/usePokemon'

export default defineEventHandler(async (event) => {
  const { getCountPokemon } = serverUsePokemon(event)

  try {
    const count = await getCountPokemon()
    
    return { count: count || 0 }
  } catch (error) {
    console.error('Pokemon count API error:', error)
    throw error
  }
})
</file>

<file path="server/utils/usePokemon.ts">
// server/utils/usePokemon.ts
import type { H3Event } from 'h3'

export const serverUsePokemon = (event: H3Event) => {
  const supabase = event.context.supabase

  const getInitPokemon = async (offset: number, limit: number) => {
    const { data, error } = await supabase
      .from('pokemon')
      .select('id, name, japanese_name, sprite_url')
      .range(offset, limit)
      .order('id')
    
    if (error) throw error
    return data || []
  }

  const getCountPokemon = async () => {
    const { count, error } = await supabase
      .from('pokemon')
      .select('*', { count: 'exact', head: true })

    if (error) throw error
    return count || 0
  }

  return {
    getInitPokemon,
    getCountPokemon
  }
}
</file>

<file path="app/plugins/auth.client.ts">
// app/plugins/auth.client.ts
import { useAuthStore } from '@/stores/auth'

export default defineNuxtPlugin(async () => {
  const authStore = useAuthStore()
  
  // import.meta.client チェック不要
  console.log('認証プラグイン: 認証状態を初期化中...')
  await authStore.initialize()
  console.log('認証プラグイン: 認証状態初期化完了')
})
</file>

<file path="app/stores/auth.ts">
// app/stores/auth.ts
import { defineStore } from 'pinia'
import { authService } from '@/services/authService'

interface AuthState {
  user: any | null
  session: any | null
  isLoading: boolean
  isInitialized: boolean
}

export const useAuthStore = defineStore('auth', {
  state: (): AuthState => ({
    user: null,
    session: null,
    isLoading: false,
    isInitialized: false
  }),

  getters: {
    // ログインしているかどうか
    isAuthenticated: (state): boolean => {
      return !!(state.user && state.session)
    },

    // ユーザーのメールアドレス
    userEmail: (state): string | null => {
      return state.user?.email || null
    }
  },

  actions: {
    /**
     * ログイン
     */
    async signIn(email: string, password: string) {
      try {
        this.isLoading = true
        const data = await authService.signIn(email, password)
        this.user = data.user
        this.session = data.session
        return { success: true }
      } catch (error) {
        console.error('ログインエラー:', error)
        return { success: false, error: (error as Error).message }
      } finally {
        this.isLoading = false
      }
    },

    /**
     * サインアップ
     */
    async signUp(email: string, password: string) {
      try {
        this.isLoading = true
        const data = await authService.signUp(email, password)
        
        this.user = data.user
        this.session = data.session
        
        return { 
          success: true, 
          needsConfirmation: !data.session // セッションがない場合はメール確認が必要
        }
      } catch (error) {
        console.error('サインアップエラー:', error)
        return { success: false, error: (error as Error).message }
      } finally {
        this.isLoading = false
      }
    },

    /**
     * ログアウト
     */
    async signOut() {
      try {
        this.isLoading = true
        await authService.signOut()
        this.user = null
        this.session = null
        return { success: true }
      } catch (error) {
        console.error('ログアウトエラー:', error)
        return { success: false, error: (error as Error).message }
      } finally {
        this.isLoading = false
      }
    },

    /**
     * 認証状態の初期化（ページ読み込み時）
     */
    async initialize() {
      try {
        // 現在のセッションを取得
        const session = await authService.getCurrentSession()
        if (session) {
          this.session = session
          this.user = session.user
        }

        // 認証状態変更の監視
        authService.onAuthStateChange((event, session) => {
          console.log('認証状態変更:', event)
          
          if (event === 'SIGNED_IN' && session) {
            this.session = session
            this.user = session.user
          } else if (event === 'SIGNED_OUT') {
            this.session = null
            this.user = null
          }
        })
        this.isInitialized = true
      } catch (error) {
        console.error('認証初期化エラー:', error)
        this.isInitialized = true 
      }
    },

    /**
     * 初期化完了まで待機
     */
    async waitForInitialization() {
      while (!this.isInitialized) {
        await new Promise(resolve => setTimeout(resolve, 50))
      }
    }
  }
})
</file>

<file path="package.json">
{
  "name": "nuxt-app",
  "type": "module",
  "private": true,
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "@pinia/nuxt": "^0.11.2",
    "@supabase/supabase-js": "^2.56.1",
    "nuxt": "^4.0.3",
    "pinia": "^3.0.3",
    "vue": "^3.5.20",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "@nuxtjs/tailwindcss": "^6.14.0"
  }
}
</file>

<file path="nuxt.config.ts">
// https://nuxt.com/docs/api/configuration/nuxt-config
export default defineNuxtConfig({
  compatibilityDate: '2025-07-15',
  devtools: { enabled: true },
  modules: [
    '@pinia/nuxt',
    '@nuxtjs/tailwindcss'
  ],
  runtimeConfig: {
    public: {
      supabaseUrl: process.env.SUPABASE_URL,
      supabaseAnonKey: process.env.SUPABASE_ANON_KEY,
    }
  },
})
</file>

<file path="app/pages/index.vue">
<script setup lang="ts">
import { usePokemonStore } from '@/stores/pokemon'
import AppHeader from '@/components/AppHeader.vue'
import PokemonGrid from '@/components/PokemonGrid.vue'
import  Pagination from '@/components/Pagination.vue'

// Storeから初期データを取得（SSRで既に格納済み）
const pokemonStore = usePokemonStore()
const { totalCount, initialPokemon, types, isInitialized, pagination } = storeToRefs(pokemonStore)

// ローディング状態管理
const isLoadingPage = ref(false)

// ページ変更処理
const handlePageChange = async (page: number) => {
  if (isLoadingPage.value) return
  
  try {
    isLoadingPage.value = true
    await pokemonStore.loadPage(page)
  } catch (error) {
    console.error('ページ変更エラー:', error)
    // TODO: エラートーストを表示するなど
  } finally {
    isLoadingPage.value = false
  }
}

// ポケモンクリック処理（将来的に詳細ページに遷移）
const handlePokemonClick = (pokemonId: number) => {
  console.log('Pokemon clicked:', pokemonId)
  // TODO: navigateTo(`/pokemon/${pokemonId}`)
}
</script>

<template>
  <div class="container mx-auto p-4">
    <!-- ヘッダー -->
    <AppHeader />

    <h1 class="text-3xl font-bold mb-6 text-center">ポケモン図鑑</h1>
    
    <!-- 初期化後の表示 -->
    <div v-if="isInitialized">
      <!-- 基本情報表示 -->
      <div class="mb-6 p-4 bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg border">
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div class="text-center">
            <p class="text-2xl font-bold text-blue-600">{{ totalCount }}</p>
            <p class="text-sm text-gray-600">総ポケモン数</p>
          </div>
          <div class="text-center">
            <p class="text-2xl font-bold text-purple-600">{{ types.length }}</p>
            <p class="text-sm text-gray-600">タイプ数</p>
          </div>
          <div class="text-center">
            <p class="text-2xl font-bold text-green-600">{{ initialPokemon.length }}</p>
            <p class="text-sm text-gray-600">表示中</p>
          </div>
        </div>
      </div>
      
      <!-- ポケモン一覧グリッド -->
      <PokemonGrid
        :pokemon="initialPokemon"
        :loading="isLoadingPage"
        @pokemon-click="handlePokemonClick"
      />

      <!-- ページネーション -->
      <div class="mt-8 mb-4">
        <Pagination
          :current-page="pagination.currentPage"
          :total-pages="pagination.totalPages"
          :loading="isLoadingPage"
          @page-change="handlePageChange"
        />
      </div>
    </div>

    <!-- 初期化中の表示 -->
    <div v-else class="text-center py-16">
      <div class="inline-flex items-center justify-center w-16 h-16 mb-4">
        <div class="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
      </div>
      <p class="text-lg text-gray-600">ポケモンデータを読み込み中...</p>
      <p class="text-sm text-gray-500 mt-2">しばらくお待ちください</p>
    </div>
  </div>
</template>

<style scoped>
.container {
  max-width: 1200px;
}
</style>
</file>

</files>
